module.exports = (function () {
  const __MODS__ = {}
  const __DEFINE__ = function (modId, func, req) {
    const m = {exports: {}, _tempexports: {}}; __MODS__[modId] = {
      status: 0, func, req, m
    }
  }
  const __REQUIRE__ = function (modId, source) { if (!__MODS__[modId]) return require(source); if (!__MODS__[modId].status) { const m = __MODS__[modId].m; m._exports = m._tempexports; const desp = Object.getOwnPropertyDescriptor(m, 'exports'); if (desp && desp.configurable) Object.defineProperty(m, 'exports', {set(val) { if (typeof val === 'object' && val !== m._exports) { m._exports.__proto__ = val.__proto__; Object.keys(val).forEach(function (k) { m._exports[k] = val[k] }) } m._tempexports = val }, get() { return m._tempexports }}); __MODS__[modId].status = 1; __MODS__[modId].func(__MODS__[modId].req, m, m.exports) } return __MODS__[modId].m.exports }
  const __REQUIRE_WILDCARD__ = function (obj) { if (obj && obj.__esModule) { return obj } else { const newObj = {}; if (obj != null) { for (const k in obj) { if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k] } } newObj.default = obj; return newObj } }
  const __REQUIRE_DEFAULT__ = function (obj) { return obj && obj.__esModule ? obj.default : obj }
  __DEFINE__(1639109434737, function (require, module, exports) {
    !(function (t, e) { if (typeof exports === 'object' && typeof module === 'object')module.exports = e(); else if (typeof define === 'function' && define.amd)define([], e); else { const o = e(); for (const r in o)(typeof exports === 'object' ? exports : t)[r] = o[r] } }(this, (function () {
      return (function (t) { const e = {}; function o(r) { if (e[r]) return e[r].exports; const i = e[r] = {i: r, l: !1, exports: {}}; return t[r].call(i.exports, i, i.exports, o), i.l = !0, i.exports } return o.m = t, o.c = e, o.d = function (t, e, r) { o.o(t, e) || Object.defineProperty(t, e, {enumerable: !0, get: r}) }, o.r = function (t) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: 'Module'}), Object.defineProperty(t, '__esModule', {value: !0}) }, o.t = function (t, e) { if (1 & e && (t = o(t)), 8 & e) return t; if (4 & e && typeof t === 'object' && t && t.__esModule) return t; const r = Object.create(null); if (o.r(r), Object.defineProperty(r, 'default', {enumerable: !0, value: t}), 2 & e && typeof t !== 'string') for (const i in t)o.d(r, i, function (e) { return t[e] }.bind(null, i)); return r }, o.n = function (t) { const e = t && t.__esModule ? function () { return t.default } : function () { return t }; return o.d(e, 'a', e), e }, o.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, o.p = '', o(o.s = 0) }([function (t, e, o) {
        const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : {default: t} }; Object.defineProperty(e, '__esModule', {value: !0}); const i = r(o(1)); const l = o(2); let n = 0; const a = (function () {
          function t(e) {
            const o = this; void 0 === e && (e = {}), this.parent = null, this.id = t.uuid(), this.style = {}, this.computedStyle = {}, this.lastComputedStyle = {}, this.children = {}, this.layoutBox = {
              left: 0, top: 0, width: 0, height: 0
            }, e = Object.assign(l.getDefaultStyle(), e), this.computedStyle = Object.assign(l.getDefaultStyle(), e), this.lastComputedStyle = Object.assign(l.getDefaultStyle(), e), Object.keys(e).forEach((function (t) {
              Object.defineProperty(o.style, t, {
                configurable: !0, enumerable: !0, get() { return e[t] }, set(r) { r !== e[t] && void 0 !== r && (o.lastComputedStyle = o.computedStyle[t], e[t] = r, o.computedStyle[t] = r, l.scalableStyles.includes(t) && o.style.scale && (o.computedStyle[t] = r * o.style.scale), t === 'scale' && l.scalableStyles.forEach((function (t) { e[t] && (o.computedStyle[t] = e[t] * r) })), t === 'hidden' && (r ? l.layoutAffectedStyles.forEach((function (t) { o.computedStyle[t] = 0 })) : l.layoutAffectedStyles.forEach((function (t) { o.computedStyle[t] = o.lastComputedStyle[t] })))) }
              })
            })), this.style.scale && l.scalableStyles.forEach((function (t) { if (o.style[t]) { const e = o.style[t] * o.style.scale; o.computedStyle[t] = e } })), e.hidden && l.layoutAffectedStyles.forEach((function (t) { o.computedStyle[t] = 0 }))
          } return t.uuid = function () { return n++ }, t.prototype.getAbsolutePosition = function (t) { if (!t) return this.getAbsolutePosition(this); if (!t.parent) return {left: 0, top: 0}; const e = this.getAbsolutePosition(t.parent); const o = e.left; const r = e.top; return {left: o + t.layoutBox.left, top: r + t.layoutBox.top} }, t.prototype.add = function (t) { t.parent = this, this.children[t.id] = t }, t.prototype.remove = function (t) { const e = this; t ? this.children[t.id] && (t.remove(), delete this.children[t.id]) : Object.keys(this.children).forEach((function (t) { e.children[t].remove(), delete e.children[t] })) }, t.prototype.getNodeTree = function () { const t = this; return {id: this.id, style: this.computedStyle, children: Object.keys(this.children).map((function (e) { return t.children[e].getNodeTree() }))} }, t.prototype.applyLayout = function (t) { const e = this; ['left', 'top', 'width', 'height'].forEach((function (o) { t.layout && typeof t.layout[o] === 'number' && (e.layoutBox[o] = t.layout[o], !e.parent || o !== 'left' && o !== 'top' || (e.layoutBox[o] += e.parent.layoutBox[o])) })), t.children.forEach((function (t) { e.children[t.id].applyLayout(t) })) }, t.prototype.layout = function () { const t = this.getNodeTree(); i.default(t), this.applyLayout(t) }, t
        }()); e.default = a
      }, function (t, e, o) {
        o.r(e); const r = (function () {
          let t; const e = 'inherit'; const o = 'ltr'; const r = 'rtl'; const i = 'row'; const l = 'row-reverse'; const n = 'column'; const a = 'column-reverse'; const u = 'flex-start'; const d = 'center'; const s = 'flex-end'; const y = 'space-between'; const c = 'space-around'; const f = 'flex-start'; const h = 'center'; const p = 'flex-end'; const g = 'stretch'; const v = 'relative'; const m = 'absolute'; const b = {
            row: 'left', 'row-reverse': 'right', column: 'top', 'column-reverse': 'bottom'
          }; const x = {
            row: 'right', 'row-reverse': 'left', column: 'bottom', 'column-reverse': 'top'
          }; const w = {
            row: 'left', 'row-reverse': 'right', column: 'top', 'column-reverse': 'bottom'
          }; const S = {
            row: 'width', 'row-reverse': 'width', column: 'height', 'column-reverse': 'height'
          }; function W(t) { return void 0 === t } function L(t) { return t === i || t === l } function k(t, e) { if (void 0 !== t.style.marginStart && L(e)) return t.style.marginStart; let o = null; switch (e) { case 'row': o = t.style.marginLeft; break; case 'row-reverse': o = t.style.marginRight; break; case 'column': o = t.style.marginTop; break; case 'column-reverse': o = t.style.marginBottom } return void 0 !== o ? o : void 0 !== t.style.margin ? t.style.margin : 0 } function j(t, e) { if (void 0 !== t.style.marginEnd && L(e)) return t.style.marginEnd; let o = null; switch (e) { case 'row': o = t.style.marginRight; break; case 'row-reverse': o = t.style.marginLeft; break; case 'column': o = t.style.marginBottom; break; case 'column-reverse': o = t.style.marginTop } return o != null ? o : void 0 !== t.style.margin ? t.style.margin : 0 } function B(t, e) { if (void 0 !== t.style.borderStartWidth && t.style.borderStartWidth >= 0 && L(e)) return t.style.borderStartWidth; let o = null; switch (e) { case 'row': o = t.style.borderLeftWidth; break; case 'row-reverse': o = t.style.borderRightWidth; break; case 'column': o = t.style.borderTopWidth; break; case 'column-reverse': o = t.style.borderBottomWidth } return o != null && o >= 0 ? o : void 0 !== t.style.borderWidth && t.style.borderWidth >= 0 ? t.style.borderWidth : 0 } function E(t, e) { if (void 0 !== t.style.borderEndWidth && t.style.borderEndWidth >= 0 && L(e)) return t.style.borderEndWidth; let o = null; switch (e) { case 'row': o = t.style.borderRightWidth; break; case 'row-reverse': o = t.style.borderLeftWidth; break; case 'column': o = t.style.borderBottomWidth; break; case 'column-reverse': o = t.style.borderTopWidth } return o != null && o >= 0 ? o : void 0 !== t.style.borderWidth && t.style.borderWidth >= 0 ? t.style.borderWidth : 0 } function C(t, e) { return (function (t, e) { if (void 0 !== t.style.paddingStart && t.style.paddingStart >= 0 && L(e)) return t.style.paddingStart; let o = null; switch (e) { case 'row': o = t.style.paddingLeft; break; case 'row-reverse': o = t.style.paddingRight; break; case 'column': o = t.style.paddingTop; break; case 'column-reverse': o = t.style.paddingBottom } return o != null && o >= 0 ? o : void 0 !== t.style.padding && t.style.padding >= 0 ? t.style.padding : 0 }(t, e)) + B(t, e) } function T(t, e) { return (function (t, e) { if (void 0 !== t.style.paddingEnd && t.style.paddingEnd >= 0 && L(e)) return t.style.paddingEnd; let o = null; switch (e) { case 'row': o = t.style.paddingRight; break; case 'row-reverse': o = t.style.paddingLeft; break; case 'column': o = t.style.paddingBottom; break; case 'column-reverse': o = t.style.paddingTop } return o != null && o >= 0 ? o : void 0 !== t.style.padding && t.style.padding >= 0 ? t.style.padding : 0 }(t, e)) + E(t, e) } function O(t, e) { return B(t, e) + E(t, e) } function _(t, e) { return k(t, e) + j(t, e) } function R(t, e) { return C(t, e) + T(t, e) } function A(t, e) { return e.style.alignSelf ? e.style.alignSelf : t.style.alignItems ? t.style.alignItems : 'stretch' } function P(t, e) { if (e === r) { if (t === i) return l; if (t === l) return i } return t } function D(t, e) { return (function (t) { return t === n || t === a }(t)) ? P(i, e) : n } function H(t) { return t.style.position ? t.style.position : 'relative' } function M(t) { return H(t) === v && t.style.flex > 0 } function I(t, e) { return t.layout[S[e]] + _(t, e) } function N(t, e) { return void 0 !== t.style[S[e]] && t.style[S[e]] >= 0 } function F(t, e) { return void 0 !== t.style[e] } function q(t, e) { return void 0 !== t.style[e] ? t.style[e] : 0 } function z(t, e, o) {
            const r = {
              row: t.style.minWidth, 'row-reverse': t.style.minWidth, column: t.style.minHeight, 'column-reverse': t.style.minHeight
            }[e]; const i = {
              row: t.style.maxWidth, 'row-reverse': t.style.maxWidth, column: t.style.maxHeight, 'column-reverse': t.style.maxHeight
            }[e]; let l = o; return void 0 !== i && i >= 0 && l > i && (l = i), void 0 !== r && r >= 0 && l < r && (l = r), l
          } function U(t, e) { return t > e ? t : e } function G(t, e) { void 0 === t.layout[S[e]] && N(t, e) && (t.layout[S[e]] = U(z(t, e, t.style[S[e]]), R(t, e))) } function J(t, e, o) { e.layout[x[o]] = t.layout[S[o]] - e.layout[S[o]] - e.layout[w[o]] } function K(t, e) { return void 0 !== t.style[b[e]] ? q(t, b[e]) : -q(t, x[e]) } function Q(r, E, Q) { const X = (function (t, r) { let i; return (i = t.style.direction ? t.style.direction : e) === e && (i = void 0 === r ? o : r), i }(r, Q)); const Y = P((function (t) { return t.style.flexDirection ? t.style.flexDirection : n }(r)), X); const Z = D(Y, X); const $ = P(i, X); G(r, Y), G(r, Z), r.layout.direction = X, r.layout[b[Y]] += k(r, Y) + K(r, Y), r.layout[x[Y]] += j(r, Y) + K(r, Y), r.layout[b[Z]] += k(r, Z) + K(r, Z), r.layout[x[Z]] += j(r, Z) + K(r, Z); const tt = r.children.length; const et = R(r, $); if (function (t) { return void 0 !== t.style.measure }(r)) { const ot = !W(r.layout[S[$]]); let rt = t; rt = N(r, $) ? r.style.width : ot ? r.layout[S[$]] : E - _(r, $), rt -= et; const it = !N(r, $) && !ot; const lt = !N(r, n) && W(r.layout[S[n]]); if (it || lt) { const nt = r.style.measure(rt); it && (r.layout.width = nt.width + et), lt && (r.layout.height = nt.height + R(r, n)) } if (tt === 0) return } let at; let ut; let dt; let st; const yt = (function (t) { return t.style.flexWrap === 'wrap' }(r)); const ct = (function (t) { return t.style.justifyContent ? t.style.justifyContent : 'flex-start' }(r)); const ft = C(r, Y); const ht = C(r, Z); const pt = R(r, Y); const gt = R(r, Z); const vt = !W(r.layout[S[Y]]); const mt = !W(r.layout[S[Z]]); const bt = L(Y); let xt = null; let wt = null; let St = t; vt && (St = r.layout[S[Y]] - pt); for (var Wt = 0, Lt = 0, kt = 0, jt = 0, Bt = 0, Et = 0; Lt < tt;) { var Ct; let Tt = 0; let Ot = 0; let _t = 0; let Rt = 0; let At = vt && ct === u || !vt && ct !== d; let Pt = At ? tt : Wt; let Dt = !0; let Ht = tt; let Mt = null; let It = null; let Nt = ft; let Ft = 0; for (at = Wt; at < tt; ++at) { if ((dt = r.children[at]).lineIndex = Et, dt.nextAbsoluteChild = null, dt.nextFlexChild = null, (Xt = A(r, dt)) === g && H(dt) === v && mt && !N(dt, Z))dt.layout[S[Z]] = U(z(dt, Z, r.layout[S[Z]] - gt - _(dt, Z)), R(dt, Z)); else if (H(dt) === m) for (xt === null && (xt = dt), wt !== null && (wt.nextAbsoluteChild = dt), wt = dt, ut = 0; ut < 2; ut++)st = ut !== 0 ? i : n, !W(r.layout[S[st]]) && !N(dt, st) && F(dt, b[st]) && F(dt, x[st]) && (dt.layout[S[st]] = U(z(dt, st, r.layout[S[st]] - R(r, st) - _(dt, st) - q(dt, b[st]) - q(dt, x[st])), R(dt, st))); let qt = 0; if (vt && M(dt) ? (Ot++, _t += dt.style.flex, Mt === null && (Mt = dt), It !== null && (It.nextFlexChild = dt), It = dt, qt = R(dt, Y) + _(dt, Y)) : (Ct = t, bt || (Ct = N(r, $) ? r.layout[S[$]] - et : E - _(r, $) - et), kt === 0 && V(dt, Ct, X), H(dt) === v && (Rt++, qt = I(dt, Y))), yt && vt && Tt + qt > St && at !== Wt) { Rt--, kt = 1; break }At && (H(dt) !== v || M(dt)) && (At = !1, Pt = at), Dt && (H(dt) !== v || Xt !== g && Xt !== f || W(dt.layout[S[Z]])) && (Dt = !1, Ht = at), At && (dt.layout[w[Y]] += Nt, vt && J(r, dt, Y), Nt += I(dt, Y), Ft = U(Ft, z(dt, Z, I(dt, Z)))), Dt && (dt.layout[w[Z]] += jt + ht, mt && J(r, dt, Z)), kt = 0, Tt += qt, Lt = at + 1 } let zt = 0; let Ut = 0; let Gt = 0; if (Gt = vt ? St - Tt : U(Tt, 0) - Tt, Ot !== 0) { var Jt; var Kt; let Qt = Gt / _t; for (It = Mt; It !== null;)(Jt = Qt * It.style.flex + R(It, Y)) !== (Kt = z(It, Y, Jt)) && (Gt -= Kt, _t -= It.style.flex), It = It.nextFlexChild; for ((Qt = Gt / _t) < 0 && (Qt = 0), It = Mt; It !== null;)It.layout[S[Y]] = z(It, Y, Qt * It.style.flex + R(It, Y)), Ct = t, N(r, $) ? Ct = r.layout[S[$]] - et : bt || (Ct = E - _(r, $) - et), V(It, Ct, X), dt = It, It = It.nextFlexChild, dt.nextFlexChild = null } else ct !== u && (ct === d ? zt = Gt / 2 : ct === s ? zt = Gt : ct === y ? (Gt = U(Gt, 0), Ut = Ot + Rt - 1 != 0 ? Gt / (Ot + Rt - 1) : 0) : ct === c && (zt = (Ut = Gt / (Ot + Rt)) / 2)); for (Nt += zt, at = Pt; at < Lt; ++at)H(dt = r.children[at]) === m && F(dt, b[Y]) ? dt.layout[w[Y]] = q(dt, b[Y]) + B(r, Y) + k(dt, Y) : (dt.layout[w[Y]] += Nt, vt && J(r, dt, Y), H(dt) === v && (Nt += Ut + I(dt, Y), Ft = U(Ft, z(dt, Z, I(dt, Z))))); let Vt = r.layout[S[Z]]; for (mt || (Vt = U(z(r, Z, Ft + gt), gt)), at = Ht; at < Lt; ++at) if (H(dt = r.children[at]) === m && F(dt, b[Z]))dt.layout[w[Z]] = q(dt, b[Z]) + B(r, Z) + k(dt, Z); else { var Xt; let Yt = ht; if (H(dt) === v) if ((Xt = A(r, dt)) === g)W(dt.layout[S[Z]]) && (dt.layout[S[Z]] = U(z(dt, Z, Vt - gt - _(dt, Z)), R(dt, Z))); else if (Xt !== f) { const Zt = Vt - gt - I(dt, Z); Yt += Xt === h ? Zt / 2 : Zt }dt.layout[w[Z]] += jt + Yt, mt && J(r, dt, Z) }jt += Ft, Bt = U(Bt, Nt), Et += 1, Wt = Lt } if (Et > 1 && mt) { const $t = r.layout[S[Z]] - gt; const te = $t - jt; let ee = 0; let oe = ht; const re = (function (t) { return t.style.alignContent ? t.style.alignContent : 'flex-start' }(r)); re === p ? oe += te : re === h ? oe += te / 2 : re === g && $t > jt && (ee = te / Et); let ie = 0; for (at = 0; at < Et; ++at) { const le = ie; let ne = 0; for (ut = le; ut < tt; ++ut) if (H(dt = r.children[ut]) === v) { if (dt.lineIndex !== at) break; W(dt.layout[S[Z]]) || (ne = U(ne, dt.layout[S[Z]] + _(dt, Z))) } for (ie = ut, ne += ee, ut = le; ut < ie; ++ut) if (H(dt = r.children[ut]) === v) { const ae = A(r, dt); if (ae === f)dt.layout[w[Z]] = oe + k(dt, Z); else if (ae === p)dt.layout[w[Z]] = oe + ne - j(dt, Z) - dt.layout[S[Z]]; else if (ae === h) { const ue = dt.layout[S[Z]]; dt.layout[w[Z]] = oe + (ne - ue) / 2 } else ae === g && (dt.layout[w[Z]] = oe + k(dt, Z)) }oe += ne } } let de = !1; let se = !1; if (vt || (r.layout[S[Y]] = U(z(r, Y, Bt + T(r, Y)), pt), Y !== l && Y !== a || (de = !0)), mt || (r.layout[S[Z]] = U(z(r, Z, jt + gt), gt), Z !== l && Z !== a || (se = !0)), de || se) for (at = 0; at < tt; ++at)dt = r.children[at], de && J(r, dt, Y), se && J(r, dt, Z); for (wt = xt; wt !== null;) { for (ut = 0; ut < 2; ut++)st = ut !== 0 ? i : n, !W(r.layout[S[st]]) && !N(wt, st) && F(wt, b[st]) && F(wt, x[st]) && (wt.layout[S[st]] = U(z(wt, st, r.layout[S[st]] - O(r, st) - _(wt, st) - q(wt, b[st]) - q(wt, x[st])), R(wt, st))), F(wt, x[st]) && !F(wt, b[st]) && (wt.layout[b[st]] = r.layout[S[st]] - wt.layout[S[st]] - q(wt, x[st])); dt = wt, wt = wt.nextAbsoluteChild, dt.nextAbsoluteChild = null } } function V(t, e, r) { t.shouldUpdate = !0; const i = t.style.direction || o; !t.isDirty && t.lastLayout && t.lastLayout.requestedHeight === t.layout.height && t.lastLayout.requestedWidth === t.layout.width && t.lastLayout.parentMaxWidth === e && t.lastLayout.direction === i ? (t.layout.width = t.lastLayout.width, t.layout.height = t.lastLayout.height, t.layout.top = t.lastLayout.top, t.layout.left = t.lastLayout.left) : (t.lastLayout || (t.lastLayout = {}), t.lastLayout.requestedWidth = t.layout.width, t.lastLayout.requestedHeight = t.layout.height, t.lastLayout.parentMaxWidth = e, t.lastLayout.direction = i, t.children.forEach((function (t) { t.layout.width = void 0, t.layout.height = void 0, t.layout.top = 0, t.layout.left = 0 })), Q(t, e, r), t.lastLayout.width = t.layout.width, t.lastLayout.height = t.layout.height, t.lastLayout.top = t.layout.top, t.lastLayout.left = t.layout.left) } return {
            layoutNodeImpl: Q,
            computeLayout: V,
            fillNodes: function t(e) {
              return e.layout && !e.isDirty || (e.layout = {
                width: void 0, height: void 0, top: 0, left: 0, right: 0, bottom: 0
              }), e.style || (e.style = {}), e.children || (e.children = []), e.children.forEach(t), e
            }
          }
        }()); e.default = function (t) { r.fillNodes(t), r.computeLayout(t) }
      }, function (t, e, o) {
        Object.defineProperty(e, '__esModule', {value: !0}); e.textStyles = ['color', 'fontSize', 'textAlign', 'fontWeight', 'lineHeight', 'lineBreak']; e.scalableStyles = ['left', 'top', 'right', 'bottom', 'width', 'height', 'margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'borderWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth']; e.layoutAffectedStyles = ['margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight', 'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight', 'width', 'height']; e.getDefaultStyle = function () {
          return {
            left: void 0, top: void 0, right: void 0, bottom: void 0, width: void 0, height: void 0, maxWidth: void 0, maxHeight: void 0, minWidth: void 0, minHeight: void 0, margin: void 0, marginLeft: void 0, marginRight: void 0, marginTop: void 0, marginBottom: void 0, padding: void 0, paddingLeft: void 0, paddingRight: void 0, paddingTop: void 0, paddingBottom: void 0, borderWidth: void 0, flexDirection: void 0, justifyContent: void 0, alignItems: void 0, alignSelf: void 0, flex: void 0, flexWrap: void 0, position: void 0, hidden: !1, scale: 1
          }
        }
      }])).default
    })))
  }, function (modId) { const map = {}; return __REQUIRE__(map[modId], modId) })
  return __REQUIRE__(1639109434737)
}())
// miniprogram-npm-outsideDeps=[]
// # sourceMappingURL=index.js.map
